Dominating set
==============

Sequential and parallel code to compute the size of the smallest dominating set of a given graph,  using C++ and openmp.

This project was made as a final project for a [course](http://www.cimec.org.ar/twiki/bin/view/Cimec/CursoCalculoParalelo) in Parallel Computing.

Context
=======

From Wikipedia: 

_In graph theory, a dominating set for a graph G = (V, E) is a subset D of V such that 
every vertex not in D is adjacent to at least one member of D. The domination number γ(G) is the number of 
vertices in a smallest dominating set for G._

_The dominating set problem concerns testing whether γ(G) ≤ K for a given graph G and input K; it is a classical 
NP-complete decision problem in computational complexity theory (Garey & Johnson 1979). 
Therefore it is believed that there is no efficient algorithm that finds a smallest dominating set for a given graph."_

In this project, the dominating set problem is solved using exhaustive search with backtracking.

Input
=====

The input format is similar to the one used in [this problem](http://uva.onlinejudge.org/external/101/10160.html "Servicing stations"). The input contains zero or more test cases. Each test case starts with two integers, the number of nodes (N) and the number of edges (E) in the graph, and is followed by E pairs of integers specifying the edges. Unlike the given problem, it's not necessary for the nodes to be labeled from 1 to N. The input ends with a pair of zeros.

Usage
=====

Sequential
----------

After compiling the code, assuming the name of the binary is `seq.out`, do:

    ./seq.out < input.txt

Parallel
--------

After compiling the code (remember to link the openmp library), assuming the name of the binary is `par.out`, do:

    ./par.out MAX_T < input.txt

where `MAX_T` is the max number of threads generated by the program. You should probably use the number of cores as `MAX_T`.
